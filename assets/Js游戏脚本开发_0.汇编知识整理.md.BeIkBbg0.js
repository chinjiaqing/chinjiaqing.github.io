import{_ as o,c as a,o as r,j as d,a2 as l,a as s,t as i}from"./chunks/framework.CHomSxuB.js";const f=JSON.parse('{"title":"汇编知识整理","description":"汇编知识整理","frontmatter":{"title":"汇编知识整理","description":"汇编知识整理","editLink":false},"headers":[],"relativePath":"Js游戏脚本开发/0.汇编知识整理.md","filePath":"Js游戏脚本开发/0.汇编知识整理.md"}'),n={name:"Js游戏脚本开发/0.汇编知识整理.md"},c={id:"frontmatter-title",tabindex:"-1"};function h(e,t,p,_,g,u){return r(),a("div",null,[d("h1",c,[s(i(e.$frontmatter.title)+" ",1),t[0]||(t[0]=d("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1))]),t[1]||(t[1]=l('<h2 id="字节术语" tabindex="-1">字节术语 <a class="header-anchor" href="#字节术语" aria-label="Permalink to &quot;字节术语&quot;">​</a></h2><table tabindex="0"><thead><tr><th>位数</th><th>术语</th><th>说明</th><th>常见数据类型</th></tr></thead><tbody><tr><td>8 位</td><td>BYTE</td><td>基本数据单位，1 字节</td><td><code>char</code></td></tr><tr><td>16 位</td><td>WORD</td><td>2 字节（通常是处理器的基本数据单位）</td><td><code>short</code></td></tr><tr><td>32 位</td><td>DWORD</td><td>4 字节（双字）</td><td><code>int</code> / <code>long</code></td></tr><tr><td>64 位</td><td>QWORD</td><td>8 字节（四字）</td><td><code>long long</code></td></tr><tr><td>128 位</td><td>Octa Word</td><td>16 字节（较少见，通常用于 SIMD）</td><td>SIMD 寄存器</td></tr><tr><td>256 位</td><td>YMM</td><td>32 字节，通常用于 SIMD（如 AVX2）</td><td>SIMD 寄存器</td></tr><tr><td>512 位</td><td>ZMM</td><td>64 字节，通常用于 SIMD（如 AVX-512）</td><td>SIMD 寄存器</td></tr></tbody></table><h2 id="寄存器" tabindex="-1">寄存器 <a class="header-anchor" href="#寄存器" aria-label="Permalink to &quot;寄存器&quot;">​</a></h2><h3 id="_32-位-x86-架构下的通用寄存器" tabindex="-1">32 位 (x86) 架构下的通用寄存器： <a class="header-anchor" href="#_32-位-x86-架构下的通用寄存器" aria-label="Permalink to &quot;32 位 (x86) 架构下的通用寄存器：&quot;">​</a></h3><ul><li><p><strong>EAX</strong>：累加寄存器（Accumulator），常用于算术运算、I/O 操作。<br><span class="emp">Windows 的代码中通常用来存放结果（返回值）</span></p></li><li><p><strong>EBX</strong>：基址寄存器（Base），用于指向数组或数据结构的基址。</p></li><li><p><strong>ECX</strong>：计数寄存器（Count），常用于循环计数器或移位操作。</p><ul><li>在 Windows x86 调用约定（如 <code>stdcall</code> 和 <code>fastcall</code>）中，<strong>ECX 通常用于传递函数的参数</strong>。具体来说，在 <code>fastcall</code> 调用约定中，==ECX 存放函数的第一个参数==。</li><li>在 <code>stdcall</code> 调用约定中，参数通常是通过栈传递的，但 <strong>ECX 仍然可以用作 ==临时数据存储== 或 ==循环计数器==</strong>。</li><li>在面向对象的 C++ 编程中，<code>this</code> 指针指向当前对象的内存地址。当调用类的成员函数时，<code>this</code> 指针会隐式地作为该成员函数的 ==第一个参数== 传递。</li><li>在 C++ 中的成员函数中，<code>this</code> 指针并没有一个固定的寄存器，而是<strong>由编译器决定</strong>。对于 <strong>Windows x86 编译器</strong>（如 MSVC），通常情况下，<code>this</code> 指针会被传递给成员函数的 ==第一个参数==，而这个参数的传递方式可能依赖于调用约定。具体来说，在 <code>fastcall</code> 调用约定中，<span class="emp">第一个参数（通常是 this 指针）会放在 ECX 寄存器中</span>。</li></ul></li><li><p><strong>EDX</strong>：数据寄存器（Data），用于 <span class="emp">存储乘法、除法的结果</span>，或与 I/O 操作相关。</p></li><li><p><strong>ESI</strong>：源索引寄存器（Source Index），用于指向源操作数，尤其是在字符串操作中。</p></li><li><p><strong>EDI</strong>：目的索引寄存器（Destination Index），用于指向目标操作数，尤其是在字符串操作中。</p></li><li></li><li><p><strong>EBP</strong>：基指针寄存器（Base Pointer），用于保存栈帧的基地址（尤其是函数调用时，栈的管理非常依赖它）。</p><ul><li>栈底 -- 因为 EBP 指向栈这种数据结构的底部，所以叫栈底</li></ul></li><li><p><strong>ESP</strong>：堆栈指针寄存器（Stack Pointer），用于指向当前栈顶位置，栈的 <code>push/pop</code> 操作都依赖于它。</p><ul><li>涉及堆栈平衡非常重要</li><li>栈顶 -- 因为 ESP 指向栈这种数据结构的顶部，所以叫栈顶</li></ul></li></ul><h3 id="_64-位架构中-寄存器名称略有变化-但功能类似" tabindex="-1">64 位架构中，寄存器名称略有变化，但功能类似： <a class="header-anchor" href="#_64-位架构中-寄存器名称略有变化-但功能类似" aria-label="Permalink to &quot;64 位架构中，寄存器名称略有变化，但功能类似：&quot;">​</a></h3><ul><li>RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP、R8~R15</li></ul>',7))])}const S=o(n,[["render",h]]);export{f as __pageData,S as default};
