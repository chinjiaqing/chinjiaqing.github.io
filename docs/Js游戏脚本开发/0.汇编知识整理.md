---
title: 汇编知识整理
description: 汇编知识整理
editLink: false
---

# {{ $frontmatter.title }}

## 字节术语

| 位数   | 术语      | 说明                                 | 常见数据类型   |
| ------ | --------- | ------------------------------------ | -------------- |
| 8 位   | BYTE      | 基本数据单位，1 字节                 | `char`         |
| 16 位  | WORD      | 2 字节（通常是处理器的基本数据单位） | `short`        |
| 32 位  | DWORD     | 4 字节（双字）                       | `int` / `long` |
| 64 位  | QWORD     | 8 字节（四字）                       | `long long`    |
| 128 位 | Octa Word | 16 字节（较少见，通常用于 SIMD）     | SIMD 寄存器    |
| 256 位 | YMM       | 32 字节，通常用于 SIMD（如 AVX2）    | SIMD 寄存器    |
| 512 位 | ZMM       | 64 字节，通常用于 SIMD（如 AVX-512） | SIMD 寄存器    |

## 通用寄存器：

| 32 位 (x86) | 64 位 (x64) | 主要用途                                        | 调用约定中的特殊用途                                                                        |
| ----------- | ----------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------- |
| EAX         | RAX         | 累加寄存器，用于算术运算、I/O 操作              | <span class="emp">Windows 中通常存放函数返回值</span>                                       |
| EBX         | RBX         | 基址寄存器，指向数组或数据结构的基址            | 通常无特殊约定，需在函数调用中保存                                                          |
| ECX         | RCX         | 计数寄存器，用于循环计数器或移位操作            | <span class="emp">Fastcall 中存放第一个参数</span>；C++ 成员函数的 `this` 指针（MSVC 约定） |
| EDX         | RDX         | 数据寄存器，存储乘法/除法的结果或 I/O 相关      | Fastcall 中存放第二个参数                                                                   |
| ESI         | RSI         | 源索引寄存器，指向字符串/数组操作的源操作数     | 通常无特殊约定，需在函数调用中保存                                                          |
| EDI         | RDI         | 目的索引寄存器，指向字符串/数组操作的目标操作数 | 通常无特殊约定，需在函数调用中保存                                                          |
| EBP         | RBP         | 基指针寄存器，保存栈帧的基地址（栈底）          | 用于访问函数参数和局部变量；需在函数调用中保存                                              |
| ESP         | RSP         | 堆栈指针寄存器，指向当前栈顶位置                | 始终跟踪栈顶位置，涉及堆栈平衡                                                              |
| -           | R8          | 64 位新增寄存器                                 | Fastcall 中存放第三个参数                                                                   |
| -           | R9          | 64 位新增寄存器                                 | Fastcall 中存放第四个参数                                                                   |
| -           | R10~R15     | 64 位新增寄存器                                 | 通用用途；部分约定中需由调用者保存（如 R10、R11）                                           |

## 标志寄存器

标志寄存器用于存储 CPU 执行操作后的状态信息，包含一个或多个标志位。标志寄存器的常见用途是在条件跳转（如 `JZ`、`JC`）中作为判断依据。

| 标志位 | 全称 | 说明 |
| ---- | ---- | ---- |
| `CF` | 进位标志（Carry Flag） | 表示加法或移位操作是否产生进位 |
| `ZF` | 零标志（Zero Flag） | 表示结果是否为零 |
| `SF` | 符号标志（Sign Flag） | 表示运算结果的符号位 |
| `OF` | 溢出标志（Overflow Flag） | 表示加法或减法是否发生了溢出 |
| `PF` | 偶校验标志（Parity Flag） | 用于检查结果是否具有偶数个 1 |
| `DF` | 方向标志（Direction Flag） | 用于字符串操作时的方向控制（增量或减量） |
| `AF` | 辅助进位标志（Auxiliary Carry Flag） | 用于 BCD 运算 |


## 栈理解

### 栈结构

1. 只有一个出口
2. 数据只能从顶端入栈
3. 先进后出

### 栈的基本操作

1. PUSH 入栈
2. POP 出栈

放入数据后，都是 ESP（栈顶）在变化。EBP（栈底）就是地基。

### 栈地址变化

- 不断 PUSH 数据，栈地址不断变小
- 不断 POP 数据，栈地址不断变大

### 栈代码理解

```asm
push 3
push eax
```

1. 先 ESP = ESP - 4
2. 再修改 [ESP] = 3

## 栈操作指令

| 指令 | 功能描述 | 栈指针变化 (ESP) |
| ---- | ---- | ---- |
| <div class=w-30>`PUSH`</div> | 将寄存器值、立即数或内存操作数压入栈顶。例：`PUSH EAX` 或 `PUSH 5`。 | `ESP -= 4` |
| `POP` | 将栈顶值弹出并存入寄存器或内存操作数。例：`POP EAX`。 | `ESP += 4` |
| `PUSHAD` | 按顺序将通用寄存器（`EAX`，`ECX`，`EDX`，`EBX`，`ESP`，`EBP`，`ESI`，`EDI`）的值压入栈。 | `ESP -= 32` |
| `POPAD` | 按顺序从栈中弹出值恢复到通用寄存器（`EDI`，`ESI`，`EBP`，`ESP`（跳过），`EBX`，`EDX`，`ECX`，`EAX`）。 | `ESP += 32` |
| `PUSHFD` | 将 32 位标志寄存器（`EFLAGS`）压入栈。 | `ESP -= 4` |
| `POPFD` | 从栈中弹出值并恢复到 32 位标志寄存器（`EFLAGS`）。 | `ESP += 4` |
| `CALL 地址` | 调用子程序，将当前指令的返回地址压入栈顶，然后跳转到目标地址。 | `ESP -= 4` |
| `RET` | 从栈中弹出返回地址并跳转到该地址。 | `ESP += 4` (或更多) |
| `ENTER` | 设置栈帧：将当前 `EBP` 压入栈，然后设置新的 `EBP` 并为局部变量分配空间。 ||
| `LEAVE` | 恢复栈帧：将 `EBP` 的值恢复到 `ESP`，然后弹出原 `EBP`。 | `ESP +=` 局部变量大小 |
| `INT imm8` | 软中断：将标志寄存器、代码段（`CS`）和指令指针（`EIP`）压入栈。 | `ESP -= 12`（假设是 32 位系统） |

## 数据传输指令

| 操作符 | 功能                           | 示例                 |
| ------ | ------------------------------ | -------------------- |
| `mov`  | 将数据从源的位置传输到目的位置 | `mov eax, ebx`       |
| `push` | 将数据压入栈                   | `push eax`           |
| `pop`  | 从栈中弹出数据到目的位置       | `pop eax`            |
| `xchg` | 交换两个操作数的值             | `xchg eax, ebx`      |
| `lea`  | 取地址                         | `lea eax, [ebx + 4]` |

## FS 段寄存器

### Windows 中 `fs` 段寄存器

- 在 Windows 里，`fs` 是段寄存器，用于指向线程的线程环境块（**TEB**，Thread Environment Block）。
- 主要用于访问当前线程的局部存储区域（而非全局数据），让线程高效存储和访问专有的信息，不需要锁定整个进程的数据。

### 32 位 Windows 中 `fs` 寄存器情况

- `fs` 寄存器的默认值指向当前线程的 TEB 地址。
- `fs:[0]` 存储着当前<span class="emp">线程的 TEB 的基地址</span>，通常用于获取该线程的相关信息。

### TEB（线程环境块）

- **定义**：为每个线程分配的数据结构。
- **用途**：存储线程相关信息。
- **特性**：每个线程有独立的 TEB。
- **存储信息**：包括线程的本地存储、异常处理、TLS（线程局部存储）、栈指针等。
- **获取 TEB 指针方式**：每个线程通过 `fs:[0]` 获取指向其 TEB 的指针。

## PEB 与 TEB

### PEB: 每个进程在 Windows 系统中都有的一个数据结构，包含了进程相关的重要信息。

```bash

typedef struct _PEB {

  //...
  UCHAR BeingDebugged;  //+0x002 是否正在调试

  //...
  UCHAR NtGlobalFlag;   //+0x068
} PEB

```

## 算数运算指令

| 操作符 | 功能       | 示例            |
| ------ | ---------- | --------------- |
| `add`  | 加法       | `add eax, ebx`  |
| `sub`  | 减法       | `sub eax, ecx`  |
| `mul`  | 无符号乘法 | `mul ecx`       |
| `imul` | 有符号乘法 | `imul eax, ecx` |
| `div`  | 无符号除法 | `div ecx`       |
| `idiv` | 有符号除法 | `idiv ecx`      |
| `inc`  | 自增       | `inc eax`       |
| `dec`  | 自减       | `dec eax`       |
| `cdq`  | 设置有符号 |                 |

## 位操作指令

| 指令  | 说明                           | 示例指令                                | 计算逻辑                                                                                                                                                                                                        |
| ----- | ------------------------------ | --------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `and` | <div class="w-20">按位与</div> | <div class="w-26">`and eax, 0xFF`</div> | 每一位相应的位都执行“与”操作：两个对应位都为 1 时，结果为 1，否则为 0。                                                                                                                                         |
| `or`  | 按位或                         | `or eax, ebx`                           | 每一位相应的位都执行“或”操作：两个对应位中，只要有一个为 1，结果为 1。                                                                                                                                          |
| `xor` | 按位异或                       | `xor eax, ebx`                          | 每一位相应的位都执行“异或”操作：两个对应位不相同，结果为 1，否则为 0。                                                                                                                                          |
| `not` | 按位取反                       | `not eax`                               | 将操作数的每一位都取反（1 变为 0，0 变为 1）。                                                                                                                                                                  |
| `shl` | 逻辑左移                       | `shl eax, 1`                            | 将操作数向左移动指定的位数，低位补 0。例如左移 1 位相当于将数值乘以 2（在无溢出情况下）。                                                                                                                       |
| `shr` | 逻辑右移                       | `shr eax, 1`                            | 将操作数向右移动指定的位数，高位补 0。例如右移 1 位相当于将无符号数值除以 2（取商的整数部分）。                                                                                                                 |
| `sal` | 算术左移                       | `sal eax, 1`                            | 与逻辑左移 `shl` 操作相同，都是将操作数向左移动指定位数，低位补 0。                                                                                                                                             |
| `sar` | 算术右移                       | `sar eax, 1`                            | 将操作数向右移动指定的位数，高位补符号位（即保持操作数的正负性不变）。例如对于有符号数，右移 1 位相当于进行算术除法除以 2（取商的整数部分）。                                                                   |
| `rol` | 循环左移                       | `rol eax, 1`                            | 将操作数向左循环移动指定的位数，从最高位移出的位会重新移入最低位。例如，若 `eax` 的值为 `0b1010`（二进制），循环左移 1 位后变为 `0b0101`。                                                                      |
| `ror` | 循环右移                       | `ror eax, 1`                            | 将操作数向右循环移动指定的位数，从最低位移出的位会重新移入最高位。例如，若 `eax` 的值为 `0b1010`（二进制），循环右移 1 位后变为 `0b0101`（这里假设是 4 位操作数示例，实际会根据寄存器位数等情况完整循环移位）。 |

## 逻辑比较指令

| 操作符 | 功能                                 | 示例            |
| ------ | ------------------------------------ | --------------- |
| `cmp`  | 比较两个操作数                       | `cmp eax, ebx`  |
| `test` | 测试（与操作，不存结果，仅设置标志） | `test eax, eax` |

`CMP` 和 `TEST` 都是常见的汇编指令，尤其在 Windows 逆向工程中经常用来进行条件判断和标志位操作。它们的主要区别在于如何影响标志寄存器以及如何使用它们来控制程序的流程。

- **`cmp` 指令**：通过执行减法运算（但不存储结果）来比较两个操作数，根据运算结果设置标志寄存器（如 `ZF`（零标志位）、`SF`（符号标志位）、`CF`（进位标志位）等），后续可以根据这些标志位进行条件跳转等操作，判断两个操作数的大小关系等（例如判断 `eax` 和 `ebx` 谁大谁小或者是否相等）。
- **`test` 指令**：执行按位与操作（同样不存储结果），主要目的是检查操作数的某些位是否为特定值（比如全为 0 等），根据与操作结果设置标志寄存器（最常用判断 `ZF` 标志位来看与操作结果是否为 0），例如 `test eax, eax` 常用来判断 `eax` 是否为 0（如果 `eax` 为 0，与操作结果为 0，`ZF` 置 1；否则 `ZF` 置 0）。

## 控制转移指令

| 操作符 | 功能 | 示例 |
| ---- | ---- | ---- |
| <span class="emp">jmp</span> | 无条件跳转 | `jmp 0x00401000` |
| `call` | 调用子程序 | `call 0x00401000` |
| `ret` | 返回到调用点 | `ret` |
| `je / jz` | 如果相等（Zero flag 置位）跳转 | `je 0x00401020` |
| `jne / jnz` | 如果不等（Zero flag 未置位）跳转 | `jne 0x00401020` |
| `jg` | 如果大于跳转 | `jg 0x00401020` |
| `jl` | 如果小于跳转 | `jl 0x00401020` |
| `jge` | 如果大于等于跳转 | `jge 0x00401020` |
| `jle` | 如果小于等于跳转 | `jle 0x00401020` |
| `loop` | 循环跳转 | `loop 0x00401020` |
| `int` | 调用中断 | `int 0x80` |
| `iret` | 从中断返回 | `iret` |